# Closures

最終更新日:

クロージャ(*Closures*)は、コード内で受け渡して使用できるある機能の独立したブロックです。 Swift のクロージャは、C 言語や Objective-C のブロック、他のプログラミング言語のラムダに似ています。

クロージャは、定数と変数への参照を、それらを定義したコンテキストからキャプチャ(*capture*)して保存できます。 これは、これらの定数と変数をスコープに閉じ込める(*closing*する)と呼ばれます。 Swift は、キャプチャに関連した全てのメモリ管理を行います。

> NOTE  
> キャプチャの概念に慣れていなくても心配しないでください。 これについては、以下の[Capturing Values](#capturing-values)で詳しく説明します。

[Functions](./functions.md)で紹介したグローバル関数やネスト関数は、実際にはクロージャの特殊なケースです。 クロージャは、次の 3 つの形式のいづれかを取ります:

* グローバル関数は、名前があり、値をキャプチャしないクロージャです
* ネスト関数は、名前があり、囲んでいる関数から値を取得できるクロージャです
* クロージャ式は、周囲のコンテキストから値をキャプチャできる軽量の構文で書かれた名前のないクロージャです

Swift のクロージャは、一般的に、簡潔で、混乱のないシンタックスで書くことを促進すうように最適化された、すっきりとした明確なスタイルを備えています。最適化には次のものが含まれます。

* コンテキストから引数と戻り値の型を推測できる
* 単一の式のクロージャは `return` キーワードなしで暗黙のリターンできる
* 引数名の短縮ができる
* 末尾のクロージャ構文を使うことができる

## Closure Expressions

[Nested Functions](./functions.md#nested-functions)で紹介したネスト関数は、より大きな関数の一部として独立したコードブロックに名前を付けて定義するための便利な手段です。ただし、完全な宣言や名前を書かずに、関数のような構造のより短いバージョンを作成できれば便利な場合もあります。これは、1 つ以上の引数を受け取る関数またはメソッドで特に当てはまります。

クロージャ式(*Closure Expressions*)は、簡潔で明瞭にインラインのクロージャを記述する方法です。クロージャ式は、明確さや意図を失うことなく、短縮された形式でクロージャを記述するためのいくつかの最適化を行うことができます。下記のクロージャ式は、複数回繰り返し使用される `sorted(by:)` メソッドを、同じ機能をより簡潔なものに改良した、最適化の例です。

### The Sorted Method

Swift の標準ライブラリは、`sorted(by:)` と呼ばれるメソッドを提供します。このメソッドは、指定した並べ替えクロージャの出力に基づいて、その型の値の配列を並べ替えます。並べ替えプロセスが完了すると、`sorted(by:)` メソッドは、古い配列と同じ型とサイズの新しい配列を返し、その要素は正しい並べ替え順序になります。元の配列は、`sorted(by:)` メソッドによって変更されません。

以下のクロージャ式の例では、`sorted(by:)` メソッドを使用して、`String` の配列をアルファベットの逆順で並べ替えています。並べ替える初期配列は次のとおりです:

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
```

`sorted(by:)` メソッドは、配列の内容と同じ型の 2 つの引数を取るクロージャを受け入れ、値が並べ替えられた後、最初の値が 2 番目の値の前に表示されるか後に表示されるかを示す `Bool` 値を返します。ソートクロージャは、最初の値が 2 番目の値の前に表示される場合は `true` を返し、それ以外の場合は `false` を返す必要があります。

この例では、`String` の配列を並べ替えているため、並べ替えクロージャは型 `(String, String) -> Bool` の関数な必要があります。

ソートクロージャを提供する 1 つの方法は、正しい型の通常の関数を記述し、それを引数として `sorted(by:)` メソッドに渡すことです。

```swift
func backward(_ s1: String, _ s2: String) -> Bool {
    return s1 > s2
}
var reversedNames = names.sorted(by: backward)
// `reversedNames` は ["Ewa", "Daniella", "Chris", "Barry", "Alex"] と等しい
```

最初の文字列(`s1`)が 2 番目の文字列(`s2`)より大きい場合、`backward(_:_:)` 関数は `true` を返し、ソートされた配列で `s1` が `s2` の前に表示される必要があることを示します。文字列内の文字の場合、「より大きい」は「アルファベットの後半に現れる」を意味します。これは、文字 `"B"` が文字 `"A"` より「大きい」ことを意味し、文字列 `"Tom"` が文字列 `"Tim"` よりも大きいことを意味します。 これにより、アルファベットの逆ソートが行われ、`"Barry"` が `"Alex"` の前に配置されます。

ただし、これは本質的に単一式の関数(`a > b`)を記述するためのかなり長い方法です。この例では、クロージャ式の構文を使用して、ソートクロージャをインラインで記述することが望ましいでしょう。

### Closure Expression Syntax

クロージャ式の構文には、次の一般的な形式があります:

![クロージャ式の構文](./../.gitbook/assets/07_closureexpressionsyntax.png)

クロージャ式構文の引数は、in-out 引数にすることができますが、デフォルト値を設定することはできません。可変個引数に名前を付けると、可変個引数を使用できます。タプルは、引数の型および戻り値の型としても使用できます。

以下の例は、上記の `backward(_:_:)` 関数のクロージャ式バージョンです。

```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1 > s2
})
```

このインラインクロージャの引数と戻り値の宣言は、`backward(_:_:)` 関数からの宣言と同じなことに注目してください。どちらの場合も、`(s1: String, s2: String) -> Bool` と書きます。ただし、インラインクロージャ式の場合、引数と戻り値の型は中括弧(`{}`)の外側ではなく、中括弧の内側に記述されます。

クロージャの本文は、`in` キーワードの後から始まります。このキーワードは、クロージャの引数と戻り値の型の定義が完了し、クロージャの本文がまもなく開始されることを示します。

クロージャの本文は非常に短いため、1 行で書くこともできます。

```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )
```

これは、`sorted(by:)` メソッドへの呼び出しが同じままなことを示しています。括弧のペア(`()`)は、メソッドの引数全体をラップしますが、引数はインラインクロージャです。

### Inferring Type From Context

ソートクロージャは、引数としてメソッドに渡されるため、Swift はその引数の型と返す値の型を推測できます。`sorted(by:)` メソッドは、文字列の配列で呼び出されるため、その引数は `(String, String) -> Bool` 型の関数な必要があります。つまり、`(String, String)` 型と `Bool` 型は、クロージャ式に記述する必要はありません。全ての型を推測できるため、戻り矢印(`->`)と引数名を囲む括弧も省略できます。

```swift
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )
```

インラインクロージャ式としてクロージャを関数またはメソッドに渡す場合、引数型と戻り値の型を推測することは常に可能です。その結果、クロージャが関数またはメソッドの引数として使用される場合、完全な形式でインラインクロージャを記述する必要はありません。

必要に応じて型を明示的にすることもできます。コードのあいまいさを回避できる場合は、そうすることをお勧めします。 `sorted(by:)` メソッドの場合、ソートが行われているという事実からクロージャの目的は明らかで、文字列の配列を扱っていることから、クロージャは `String` で機能していると読み手は容易に想定できます。

### Implicit Returns from Single-Expression Closures

上記の例のように、単一式のクロージャは、宣言から `return` キーワードを省略して結果を暗黙的に返すことができます。

```swift
reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
```

ここで、`sorted(by:)` メソッドの引数の関数型は、`Bool` 値がクロージャによって返される必要があることを明確にしています。 クロージャの本文は、ブール値を返す単一の式(`s1 > s2`)のため、あいまいさはなく、`return` キーワードは省略できます。

### Shorthand Argument Names

Swift は、インラインクロージャに短縮引数名(*Shorthand Argument Names*)を自動的に提供しています。これを使用して、クロージャの引数の値を `$0`、`$1`、`$2` などの名前で参照できます。

クロージャ式内でこれらの省略引数名を使用する場合は、クロージャの引数リストをその定義から省略できます。短縮引数名の型は、期待されている関数型から推測され、最も大きい番号の短縮引数で、クロージャが受け取る引数の数が決まります。クロージャ式は本文だけで完全に構築(推論)できているため、`in` キーワードは省略できます。

```swift
reversedNames = names.sorted(by: { $0 > $1 } )
```

ここで、`$0` と `$1` は、クロージャの最初と 2 番目の文字列引数を指します。 `$1` は最大数の省略引数のため、クロージャは 2 つの引数を取ることがわかります。ここでの `sorted(by:)` 関数は、引数が両方とも文字列のクロージャを想定しているため、省略形の引数 `$0` と `$1` は両方とも `String` 型です。

### Operator Methods

実際には、上記のクロージャ式を記述するさらに短い方法があります。Swift の `String` 型は、大なり演算子（`>`）の文字列固有の実装を、`String` 型の 2 つの引数を持ち、`Bool` 型の値を返すメソッドとして定義しています。これは、`sorted(by:)` メソッドに必要なメソッド型と完全に一致します。したがって、`>` 演算子を渡すだけで、Swift は文字列固有の実装を使用していると推測します。

```swift
reversedNames = names.sorted(by: >)
```

演算子メソッドの詳細については、[Operator Methods](./advanced-operators.md#operator-methods)を参照ください。

## Trailing Closures

## Capturing Values

## Closures Are Reference Types

## Escaping Closures

## Autoclosures
