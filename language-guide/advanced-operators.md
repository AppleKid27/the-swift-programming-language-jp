# Advanced Operators

最終更新日:

[Basic Operators](./basic-operators.md)で説明されている演算子に加えて、Swift は、より複雑な値操作を実行するいくつかの高度な演算子を提供します。これらには、C 言語および Objective-C でおなじみの全てのビット単位およびビットシフト演算子が含まれます。

C 言語の算術演算子とは異なり、Swift の算術演算子はデフォルトでオーバーフローしません。オーバーフロー動作はトラップされ、エラーとして報告されます。オーバーフロー動作を選択するには、オーバーフロー加算演算子(`&+`)など、デフォルトでオーバーフローする Swift の 2 番目の算術演算子セットを使用します。これらのオーバーフロー演算子は全て、アンパサンド(`&`)で始まります。

独自の構造体、クラス、および列挙型を定義する場合、これらの独自型に標準の Swift 演算子の独自の実装を提供すると便利な場合があります。Swift では、簡単にこれらの演算子のカスタマイズ実装を提供し、作成した型ごとにそれらの動作を正確に決めることができます。

事前定義された演算子に限定されません。Swift では、独自の優先順位と結合規則を使用して、独自の前置、中置、後置、および代入演算子を自由に定義できます。これらの演算子は、事前定義の演算子と同様にコードで使用および適用でき、定義した独自の演算子をサポートするように既存の型を拡張することもできます。

## Bitwise Operators(ビット演算子)

ビットごとの演算子を使用すると、データ構造内の個々の生データビットを操作できます。これらは、グラフィクスプログラミングやデバイスドライバーの作成など、低レベルのプログラミングでよく使用されます。ビットごとの演算子は、独自のプロトコルを介した通信用データのエンコードおよびデコードなど、外部ソースからの生データを操作する場合にも役立ちます。

Swift は、下記で説明するように、C 言語に見られる全てのビット演算子をサポートしています。

### Bitwise NOT Operator(ビットNOT演算子)

ビット NOT 演算子(`~`)は、数値の全てのビットを反転します。

![ビットNOT演算子](./../.gitbook/assets/bitwiseNOT_2x.png)

ビット NOT 演算子は前置演算子で、空白を含めずに演算対象の値の直前に置きます。

```swift
let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits  // 11110000 と等しい
```

`UInt8` 整数には 8 ビットの、`0` から `255` までの任意の値を格納できます。この例では、`UInt8` 整数をバイナリ値 `00001111` で初期化し、最初の 4 ビットが `0` に設定され、2 番目の 4 ビットが `1` に設定されています。これは、10 進数の `15` に相当します。

次に、ビット NOT 演算子を使用して、`invertedBits` と呼ばれる新しい定数を作成します。これは `initialBits` と同じですが、全てのビットが反転されています。ゼロは 1 になり、1 はゼロになります。`invertedBits` の値は `11110000` で、符号なし 10 進数の `240` に相当します。

### Bitwise AND Operator(ビットAND演算子)

ビット AND 演算子(`&`)は、2 つの数値のビットを合成します。両方の入力数値のビットが 1 の場合にのみ、ビットが 1 になり、新しい数値を返します:

![ビットAND演算子](./../.gitbook/assets/bitwiseAND_2x.png)

下記の例では、`firstSixBits` と `lastSixBits` の値は両方とも、4 つの中間ビットに `1` が設定されています。ビット AND 演算子はそれらを組み合わせて、符号なし 10 進数の `60` に等しい数値 `00111100` を作成します。

```swift
let firstSixBits: UInt8 = 0b11111100
let lastSixBits: UInt8  = 0b00111111
let middleFourBits = firstSixBits & lastSixBits  // 00111100 と等しい
```

### Bitwise OR Operator(ビットOR演算子)

ビット OR 演算子(`|`)は、2 つの数値のビットを比較します。演算子は、いずれかの入力数値のビットが `1` に等しい場合、ビットは `1` になり、新しい数値を返します:

![ビットOR演算子](./../.gitbook/assets/bitwiseOR_2x.png)

下記の例では、`someBits` と `moreBits` の値の異なるビットに `1` が設定されています。ビットごとの OR 演算子はそれらを組み合わせて、符号なし 10 進数の `254` に等しい `11111110` という数値を作成します。

```swift
let someBits: UInt8 = 0b10110010
let moreBits: UInt8 = 0b01011110
let combinedbits = someBits | moreBits  // 11111110 と等しい
```

### Bitwise XOR Operator(ビットXOR演算子)

ビット XOR 演算子、つまり「排他的論理和演算子」(`^`)は、2 つの数値のビットを比較します。演算子は、入力ビットが異なる場合はビットに `1` が設定され、入力ビットが同じ場合は `0` が設定される新しい数値を返します:

![ビットXOR演算子](./../.gitbook/assets/bitwiseXOR_2x.png)

下記の例では、`firstBits` と `otherBits` の値はそれぞれ、他の場所にはないビットに `1` が設定されています。ビット XOR 演算子は、これらのビット両方に `1` を設定します。`firstBits` および `otherBits` の他の全てのビットは値が一致しているので、`0` が設定されます。

```swift
let firstBits: UInt8 = 0b00010100
let otherBits: UInt8 = 0b00000101
let outputBits = firstBits ^ otherBits  // 00010001 と等しい
```

### Bitwise Left and Right Shift Operators(ビット左右シフト演算子)

ビット左シフト演算子(`<<`)およびビット右シフト演算子(`>>`)は、下記で定義されている規則に従って、数値内の全てのビットを特定の桁数だけ左または右に移動します。

ビット左シフトと右シフトには、整数を 2 倍に乗算または除算する効果があります。整数のビットを 1 桁左にシフトするとその値は 2 倍になり、1 桁右にシフトすると値は半分になります。

#### Shifting Behavior for Unsigned Integers(符号なし整数のシフト演算)

---

符号なし整数のビットシフト動作は次のとおりです。

1. 既存のビットは、要求された桁数だけ左または右に移動します
2. 整数のストレージの境界を超えて移動したビットはすべて破棄されます
3. 元のビットを左または右に移動した後に残ったスペースにゼロが挿入されます

このアプローチは、論理シフト(*logical shift*)として知られています。

下の図は、`11111111 << 1`(`11111111` を 1 桁左にずらしたもの)と `11111111 >> 1`(`11111111` を右に 1 桁ずらしたもの)の結果を示しています。青色の数字はシフトされ、灰色の数字は破棄され、オレンジ色のにはゼロが挿入されます。

![符号なし整数のシフト演算](./../.gitbook/assets/bitshiftUnsigned_2x.png)

Swift コードでのビットシフトの様子は次のとおりです:

```swift
let shiftBits: UInt8 = 4   // バイナリ内の 00000100
shiftBits << 1             // 00001000
shiftBits << 2             // 00010000
shiftBits << 5             // 10000000
shiftBits << 6             // 00000000
shiftBits >> 2             // 00000001
```

ビットシフトを使用して、他のデータ型内の値をエンコードおよびデコードできます:

```swift
let pink: UInt32 = 0xCC6699
let redComponent = (pink & 0xFF0000) >> 16    // redComponent は 0xCC または 204
let greenComponent = (pink & 0x00FF00) >> 8   // greenComponent は 0x66 または 102
let blueComponent = pink & 0x0000FF           // blueComponent は 0x99 または 153
```

この例では、`pink` という `UInt32` 定数を使用して、ピンク色の CSS 値を格納します。CSS カラー値 `#CC6699` は、Swift の 16 進数で `0xCC6699` になります。次に、この色は、ビット AND 演算子(`&`)とビット右シフト演算子(`>>`)によって、赤(`CC`)、緑(`66`)、および青(`99`)のコンポーネントに分解されます。

赤のコンポーネントは、数値 `0xCC6699` と `0xFF0000` の間でビット AND 演算をすることによって取得されます。`0xFF0000` のゼロは、`0xCC6699` の 2 番目と 3 番目のバイトを効果的に「マスク」し、`6699` を無視して、結果として `0xCC0000` を残します。

次に、この番号が 16 桁右にシフトされます(`>> 16`)。16 進数の文字の各ペアは 8 ビットを使用するため、16 桁右に移動すると、`0xCC0000` が `0x0000CC` に変換されます。これは、10 進数 `204`、 `0xCC` と同じです。

同様に、緑のコンポーネントは、数値 `0xCC6699` と `0x00FF00` の間でビット AND 演算をすることによって取得され、`0x006600` の出力値が得られます。次に、この出力値が 8 桁右にシフトされ、10 進数 `102`、`0x66` が得られます。

最後に、青のコンポーネントは、数値 `0xCC6699` と `0x0000FF` の間でビット AND 演算をすることによって取得され、`0x000099` の出力値が得られます。`0x000099` はすでに 10 進数 `153`、 `0x99` に等しいため、この値は右にシフトせずに使用されます。

#### Shifting Behavior for Signed Integers(符号あり整数のシフト演算)

## Overflow Operators(オーバーフロー演算子)

### Value Overflow(値のオーバーフロー)

## Precedence and Associativity(優先順位と結合規則)

## Operator Methods(演算子メソッド)

### Prefix and Postfix Operators(前置、後置演算子)

### Compound Assignment Operators(合成代入演算子)

### Equivalence Operators(比較演算子)

## Custom Operators(カスタム演算子)

### Precedence for Custom Infix Operators(カスタム中置演算子の優先順位)

## Result Builders(リザルトビルダー)