# Advanced Operators

最終更新日:

[Basic Operators](./basic-operators.md)で説明されている演算子に加えて、Swift は、より複雑な値操作を実行するいくつかの高度な演算子を提供します。これらには、C 言語および Objective-C でおなじみの全てのビット単位およびビットシフト演算子が含まれます。

C 言語の算術演算子とは異なり、Swift の算術演算子はデフォルトでオーバーフローしません。オーバーフロー動作はトラップされ、エラーとして報告されます。オーバーフロー動作を選択するには、オーバーフロー加算演算子(`&+`)など、デフォルトでオーバーフローする Swift の 2 番目の算術演算子セットを使用します。これらのオーバーフロー演算子は全て、アンパサンド(`&`)で始まります。

独自の構造体、クラス、および列挙型を定義する場合、これらの独自型に標準の Swift 演算子の独自の実装を提供すると便利な場合があります。Swift では、簡単にこれらの演算子のカスタマイズ実装を提供し、作成した型ごとにそれらの動作を正確に決めることができます。

事前定義された演算子に限定されません。Swift では、独自の優先順位と結合規則を使用して、独自の前置、中置、後置、および代入演算子を自由に定義できます。これらの演算子は、事前定義の演算子と同様にコードで使用および適用でき、定義した独自の演算子をサポートするように既存の型を拡張することもできます。

## Bitwise Operators(ビット演算子)

ビットごとの演算子を使用すると、データ構造内の個々の生データビットを操作できます。これらは、グラフィクスプログラミングやデバイスドライバーの作成など、低レベルのプログラミングでよく使用されます。ビットごとの演算子は、独自のプロトコルを介した通信用データのエンコードおよびデコードなど、外部ソースからの生データを操作する場合にも役立ちます。

Swift は、下記で説明するように、C 言語に見られる全てのビット演算子をサポートしています。

### Bitwise NOT Operator(ビットNOT演算子)

ビット NOT 演算子(`~`)は、数値の全てのビットを反転します。

![ビットNOT演算子](./../.gitbook/assets/bitwiseNOT_2x.png)

ビット NOT 演算子は前置演算子で、空白を含めずに演算対象の値の直前に置きます。

```swift
let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits  // 11110000 と等しい
```

`UInt8` 整数には 8 ビットの、`0` から `255` までの任意の値を格納できます。この例では、`UInt8` 整数をバイナリ値 `00001111` で初期化し、最初の 4 ビットが `0` に設定され、2 番目の 4 ビットが `1` に設定されています。これは、10 進数の `15` に相当します。

次に、ビット NOT 演算子を使用して、`invertedBits` と呼ばれる新しい定数を作成します。これは `initialBits` と同じですが、全てのビットが反転されています。0 は 1 になり、1 は 0 になります。`invertedBits` の値は `11110000` で、符号なし 10 進数の `240` に相当します。

### Bitwise AND Operator(ビットAND演算子)

ビット AND 演算子(`&`)は、2 つの数値のビットを合成します。両方の入力数値のビットが 1 の場合にのみ、ビットが 1 になり、新しい数値を返します:

![ビットAND演算子](./../.gitbook/assets/bitwiseAND_2x.png)

下記の例では、`firstSixBits` と `lastSixBits` の値は両方とも、4 つの中間ビットに `1` が設定されています。ビット AND 演算子はそれらを組み合わせて、符号なし 10 進数の `60` に等しい数値 `00111100` を作成します。

```swift
let firstSixBits: UInt8 = 0b11111100
let lastSixBits: UInt8  = 0b00111111
let middleFourBits = firstSixBits & lastSixBits  // 00111100 と等しい
```

### Bitwise OR Operator(ビットOR演算子)

ビット OR 演算子(`|`)は、2 つの数値のビットを比較します。演算子は、いずれかの入力数値のビットが `1` に等しい場合、ビットは `1` になり、新しい数値を返します:

![ビットOR演算子](./../.gitbook/assets/bitwiseOR_2x.png)

下記の例では、`someBits` と `moreBits` の値の異なるビットに `1` が設定されています。ビットごとの OR 演算子はそれらを組み合わせて、符号なし 10 進数の `254` に等しい `11111110` という数値を作成します。

```swift
let someBits: UInt8 = 0b10110010
let moreBits: UInt8 = 0b01011110
let combinedbits = someBits | moreBits  // 11111110 と等しい
```

### Bitwise XOR Operator(ビットXOR演算子)

ビット XOR 演算子、つまり「排他的論理和演算子」(`^`)は、2 つの数値のビットを比較します。演算子は、入力ビットが異なる場合はビットに `1` が設定され、入力ビットが同じ場合は `0` が設定される新しい数値を返します:

![ビットXOR演算子](./../.gitbook/assets/bitwiseXOR_2x.png)

下記の例では、`firstBits` と `otherBits` の値はそれぞれ、他の場所にはないビットに `1` が設定されています。ビット XOR 演算子は、これらのビット両方に `1` を設定します。`firstBits` および `otherBits` の他の全てのビットは値が一致しているので、`0` が設定されます。

```swift
let firstBits: UInt8 = 0b00010100
let otherBits: UInt8 = 0b00000101
let outputBits = firstBits ^ otherBits  // 00010001 と等しい
```

### Bitwise Left and Right Shift Operators(ビット左右シフト演算子)

ビット左シフト演算子(`<<`)およびビット右シフト演算子(`>>`)は、下記で定義されている規則に従って、数値内の全てのビットを特定の桁数だけ左または右に移動します。

ビット左シフトと右シフトには、整数を 2 倍に乗算または除算する効果があります。整数のビットを 1 桁左にシフトするとその値は 2 倍になり、1 桁右にシフトすると値は半分になります。

#### Shifting Behavior for Unsigned Integers(符号なし整数のシフト演算)

---

符号なし整数のビットシフト動作は次のとおりです。

1. 既存のビットは、要求された桁数だけ左または右に移動します
2. 整数のストレージの境界を超えて移動したビットは全て破棄されます
3. 元のビットを左または右に移動した後に残ったスペースに 0 が挿入されます

このアプローチは、論理シフト(*logical shift*)として知られています。

下の図は、`11111111 << 1`(`11111111` を 1 桁左にずらしたもの)と `11111111 >> 1`(`11111111` を右に 1 桁ずらしたもの)の結果を示しています。青色の数字はシフトされ、灰色の数字は破棄され、オレンジ色のには 0 が挿入されます。

![符号なし整数のシフト演算](./../.gitbook/assets/bitshiftUnsigned_2x.png)

Swift コードでのビットシフトの様子は次のとおりです:

```swift
let shiftBits: UInt8 = 4   // バイナリ内の 00000100
shiftBits << 1             // 00001000
shiftBits << 2             // 00010000
shiftBits << 5             // 10000000
shiftBits << 6             // 00000000
shiftBits >> 2             // 00000001
```

ビットシフトを使用して、他のデータ型内の値をエンコードおよびデコードできます:

```swift
let pink: UInt32 = 0xCC6699
let redComponent = (pink & 0xFF0000) >> 16    // redComponent は 0xCC または 204
let greenComponent = (pink & 0x00FF00) >> 8   // greenComponent は 0x66 または 102
let blueComponent = pink & 0x0000FF           // blueComponent は 0x99 または 153
```

この例では、`pink` という `UInt32` 定数を使用して、ピンク色の CSS 値を格納します。CSS カラー値 `#CC6699` は、Swift の 16 進数で `0xCC6699` になります。次に、この色は、ビット AND 演算子(`&`)とビット右シフト演算子(`>>`)によって、赤(`CC`)、緑(`66`)、および青(`99`)のコンポーネントに分解されます。

赤のコンポーネントは、数値 `0xCC6699` と `0xFF0000` の間でビット AND 演算をすることによって取得されます。`0xFF0000` の 0 は、`0xCC6699` の 2 番目と 3 番目のバイトを効果的に「マスク」し、`6699` を無視して、結果として `0xCC0000` を残します。

次に、この番号が 16 桁右にシフトされます(`>> 16`)。16 進数の文字の各ペアは 8 ビットを使用するため、16 桁右に移動すると、`0xCC0000` が `0x0000CC` に変換されます。これは、10 進数 `204`、 `0xCC` と同じです。

同様に、緑のコンポーネントは、数値 `0xCC6699` と `0x00FF00` の間でビット AND 演算をすることによって取得され、`0x006600` の出力値が得られます。次に、この出力値が 8 桁右にシフトされ、10 進数 `102`、`0x66` が得られます。

最後に、青のコンポーネントは、数値 `0xCC6699` と `0x0000FF` の間でビット AND 演算をすることによって取得され、`0x000099` の出力値が得られます。`0x000099` はすでに 10 進数 `153`、 `0x99` に等しいため、この値は右にシフトせずに使用されます。

#### Shifting Behavior for Signed Integers(符号あり整数のシフト演算)

---

符号付き整数のシフト演算は、符号なし整数よりも符号付き整数の方が複雑です。これは、符号付き整数がバイナリで表現される方法に由来します。(下記の例は、簡単にするために 8 ビットの符号付き整数に基づいていますが、同じ原則が任意のサイズの符号付き整数に適用されます)

符号付き整数は、最初のビット(符号ビット(*sign bit*)と呼ばれます)を使用して、整数が正か負かを示します。符号ビット `0` は正を意味し、符号ビット `1` は負を意味します。

残りのビット(値ビット(*value bits*)と呼ばれます)には、実際の値が格納されています。正の数は、符号なし整数の場合とまったく同じ方法で、`0` から数えて格納されています。`Int8` 内からビットで数値 `4` を表す方法は次のとおりです:

![符号付き整数4](./../.gitbook/assets/bitshiftSignedFour_2x.png)

符号ビットは `0`(「正」を意味します)で、7 つの値ビットは 2 進数表記で書かれた数字の `4` です。

ただし、負の数は別の方法で格納されます。それらは、`2` から `n` のべき乗の絶対値を引くことによって保持されます。ここで、`n` は値のビット数です。8 ビットの数値には 7 つの値ビットがあるため、これは 2 の 7 乗、つまり `128` を意味します。

`Int8` 内からビットで数値 `-4` を表す方法は次のとおりです:

![符号付き整数-4](./../.gitbook/assets/bitshiftSignedMinusFour_2x.png)

今回は、符号ビットは `1`(「負」を意味する)で、7 つの値ビットは `124` のバイナリ値(`128 - 4`)です:

![符号付き整数124](./../.gitbook/assets/bitshiftSignedMinusFourValue_2x.png)

負の数のこのエンコーディングは、2 の補数表現(*complement representation*)と呼ばれています。負の数を表すのは珍しい方法に見えるかもしれませんが、いくつかの利点があります。

まず、8 ビット全て(符号ビットを含む)の標準の 2 進数加算を実行し、完了したら 8 ビットに収まらないものは全て破棄するだけで、`-1` を `-4` に加算できます:

![符号付き整数負の数の加算](./../.gitbook/assets/bitshiftSignedAddition_2x.png)

次に、2 の補数表現では、負の数のビットを正の数のように左右にシフトすることもできますが、左にシフトするたびにビットを 2 倍し、右にシフトするたびにビットを半分にします。これを実現するために、符号付き整数を右にシフトするときに追加の規則が使用されます。符号付き整数を右にシフトするときは、符号なし整数と同じ規則を適用しますが、左側の空のビットを 0 で埋めるのではなく、符号ビットで埋めます。

![符号付き整数ビットシフト](./../.gitbook/assets/bitshiftSigned_2x.png)

このアクションにより、符号付き整数が右にシフトされた後も同じ符号を持つようになります。これは算術シフト(*arithmetic shift*)と呼ばれています。

正の数と負の数は特殊な方法で保持されるため、どちらかを右にシフトすると 0 に近づきます。このシフト中に符号ビットを同じに保つということは、値が 0 に近づいても負の整数は負の値のままになることを意味します。

## Overflow Operators(オーバーフロー演算子)

### Value Overflow(値のオーバーフロー)

## Precedence and Associativity(優先順位と結合規則)

## Operator Methods(演算子メソッド)

### Prefix and Postfix Operators(前置、後置演算子)

### Compound Assignment Operators(合成代入演算子)

### Equivalence Operators(比較演算子)

## Custom Operators(カスタム演算子)

### Precedence for Custom Infix Operators(カスタム中置演算子の優先順位)

## Result Builders(リザルトビルダー)